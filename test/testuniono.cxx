#include "godtest.h"

// Returns a point that was read from .bin file prepared by gendata4test program
libgod::Point readPoint (size_t dp, size_t dc, std::ifstream& file) {
	libgod::Point p(dp,dc);
	
	size_t ind = 0;
	double *p_data = new double [dp+dc];
	
	file.read((char*)p_data, sizeof(double)*(dp+dc));
	
	for (size_t i=0; i < dp; i++) {
		p.setParameterAt(i,p_data[ind]);
		ind++;
	}
	for (size_t i=0; i < dc; i++) {
		p.setCriterionAt(i,p_data[ind]);
		ind++;
	}

	delete(p_data);
	
	return p;
}

// Returns a point with random parameters and criteria
libgod::Point randPoint (size_t dp, size_t dc) {
	libgod::Point p(dp,dc);
	
	for (size_t i = 0; i < dp; i++)
		p.setParameterAt(i, 1.0 * rand() / RAND_MAX);
	for (size_t i = 0; i < dc; i++)
		p.setCriterionAt(i, 1.0 * rand() / RAND_MAX);
		
	return p;
}

int main (int argc, char *argv[]) {
	INIT_TEST(1);
	
	bool is_thrown = false;

	// Test 1. Check that exception is thrown if input file isn't found
	if (strstr(argv[1],"nofound")) {
		try {
			libgod::Union un1;	
			libgod::Storage st1(argv[1]);

			st1.read(un1);
		}
		catch (libgod::GodError& ge) {
			is_thrown = 1;
		}
		ASSERT_TRUE(is_thrown);
		return 0;
	}

	// Test 2. Check that saved union corresponds with ideal data file
	// Union with 1 empty set
	if (strstr(argv[1],"input.union1")) {
		try {
			libgod::Storage st(std::string(argv[1])+".out");
			libgod::Union un(10,7);
			un.add();
			
			st.write(un);
		}
		catch (libgod::GodError& ge) {
			std::cerr << "Test error (" + std::string(argv[1]) + "): "  << ge.what() << std::endl;
		}
		return 0;
	}

	// Test 3. Union with 2 sets, 2 points each
	if (strstr(argv[1],"input.union2")) {
		try {
			libgod::Storage st(std::string(argv[1])+".out");
			libgod::Union un(5,3);
			double parameters[] = {1.2, -0.9, 6.7, 1.209, 4.731};
			double criteria[] = {0.99, 0.76, 0.12};
			
			for (int i=0; i<2; i++) {
				libgod::Set& s = un.add();
				for (int j=0; j<2; j++) {
					libgod::Point& p = s.add();
					p.setParameters(parameters);
					p.setCriteria(criteria);
				}
			}
			
			st.write(un);
		}
		catch (libgod::GodError& ge) {
			std::cerr << "Test error (" + std::string(argv[1]) + "): "  << ge.what() << std::endl;
		}
		return 0;
	}

	// Test 4. Union wirh 10 sets, (i+1)*10 points each
	// --------------------------------------------------
	// NOTE: each time when input.union3 is regenerated by gendata4test, 
	//       input.union3.bin aslo should be refreshed
	if (strstr(argv[1],"input.union3")) {
		try {
			const size_t dp = 2, dc = 3;
			libgod::Storage st(std::string(argv[1])+".out");
			libgod::Union un(dp,dc);
			
			std::ifstream datafile;
			datafile.open((std::string(argv[1])+".bin").c_str(), std::ios::binary | std::ios::in );
		
			for (int i=0; i<10; i++) {
				libgod::Set& s = un.add();
				for (int j=0; j<(i+1); j++) {
					s.add(readPoint(dp,dc,datafile));
				}
			}
			
			st.write(un);
			datafile.close();
		}
		catch (libgod::GodError& ge) {
			std::cerr << "Test error (" + std::string(argv[1]) + "): "  << ge.what() << std::endl;
		}
		return 0;
	}
	
	// Test 5. Serialization of random Union size > 20 MB.
	//	Number of points = 600000
	//	Number of sets   = 1000
	if (strstr(argv[1], "input.unionrand")) {
		try {
			const size_t dp = 3, dc = 2;
			const size_t dsets = 1000, dpoints_per_set = 600;
			
			libgod::Storage st(argv[1]);
			libgod::Union un(dp, dc);
			
			for (int i=0; i<dsets; i++) {
				libgod::Set& s = un.add();
				for (int j=0; j < dpoints_per_set; j++)
					s.add(randPoint(dp,dc));
			}
			
			st.write(un);
		}
		catch (libgod::GodError& ge) {
			std::cerr << "Test error (" + std::string(argv[1]) + "): " << ge.what() << std::endl;
		}

		return 0;
	}
	

	return 0;
}
